@file:Suppress("UNCHECKED_CAST")

package xyz.xenondevs.commons.provider.immutable

import xyz.xenondevs.commons.provider.Provider

/**
 * Creates and returns a new [Provider] that maps the value of [this][Provider]
 * using the [transform] function.
 */
fun <T : Any, R> Provider<T>.map(transform: (T) -> R): Provider<R> {
    val provider = MapEverythingProvider(this, transform)
    addChild(provider)
    return provider
}

/**
 * Creates and returns a new [Provider] that maps all non-null values of [this][Provider]
 * using the [transform] function.
 * Null values will be passed through without transformation.
 */
fun <T, R> Provider<T?>.mapNonNull(transform: (T & Any) -> R): Provider<R?> {
    val provider = MapNonNullProvider(this, transform)
    addChild(provider)
    return provider
}

/**
 * Creates and returns a new [Provider] that maps each element of the [Collection] obtained from [this][Provider]
 * using the [transform] function.
 */
fun <T, R> Provider<out Collection<T>>.mapEach(transform: (T) -> R): Provider<List<R>> {
    val provider = MapEachProvider(this, ::ArrayList, transform) as Provider<List<R>>
    addChild(provider)
    return provider
}

/**
 * Creates and returns a new [Provider] that maps each element of the [Collection] obtained from [this][Provider]
 * using the [transform] function and adds the results to a collection created by [makeCollection].
 */
fun <T, R, C : MutableCollection<R>> Provider<out Collection<T>>.mapEachTo(makeCollection: () -> C, transform: (T) -> R): Provider<C> {
    val provider = MapEachProvider(this, makeCollection, transform)
    addChild(provider)
    return provider
}

/**
 * Creates and returns a new [Provider] that maps each element of the [Collection] obtained from [this][Provider]
 * using the [transform] function and filters out all null results.
 */
fun <T, R : Any> Provider<out Collection<T>>.mapEachNotNull(transform: (T) -> R?): Provider<List<R>> {
    val provider = MapEachNotNullProvider(this, ::ArrayList, transform) as Provider<List<R>>
    addChild(provider)
    return provider
}

/**
 * Creates and returns a new [Provider] that maps each element of the [Collection] obtained from [this][Provider]
 * using the [transform] function and filters out all null results.
 * The results are added to a collection created by [makeCollection].
 */
fun <T, R : Any, C : MutableCollection<R>> Provider<out Collection<T>>.mapEachNotNullTo(makeCollection: () -> C, transform: (T) -> R?): Provider<C> {
    val provider = MapEachNotNullProvider(this, makeCollection, transform)
    addChild(provider)
    return provider
}

/**
 * Creates and returns a new [Provider] that flat-maps the elements of the [List] obtained from [this][Provider]
 * using the [transform] function.
 */
fun <T, R> Provider<List<T>>.flatMap(transform: (T) -> List<R>): Provider<List<R>> {
    val provider = FlatMapProvider(this, transform)
    addChild(provider)
    return provider
}

/**
 * Creates and returns a new [Provider] that flattens the [List] of [Lists][List] obtained from [this][Provider].
 */
fun <T> Provider<List<List<T>>>.flatten(): Provider<List<T>> {
    val provider = FlatMapProvider(this) { it }
    addChild(provider)
    return provider
}

/**
 * Creates and returns a new [Provider] that merges all [Maps][Map] obtained from [this][Provider] into a single [Map].
 */
fun <K, V> Provider<List<Map<K, V>>>.merged(): Provider<Map<K, V>> {
    val provider = MergeMapsProvider(this, ::LinkedHashMap)
    addChild(provider)
    return provider
}

/**
 * Creates and returns a new [Provider] that merges all [Maps][Map] obtained from [this][Provider] into a single [Map],
 * which is created by the [createMap] function.
 */
fun <K, V> Provider<List<Map<K, V>>>.merged(createMap: () -> MutableMap<K, V>): Provider<Map<K, V>> {
    val provider = MergeMapsProvider(this, createMap)
    addChild(provider)
    return provider
}

/**
 * Creates and returns a new [Provider] that throws an [IllegalArgumentException]
 * with a message generated by [message] if [condition] fails.
 */
fun <T> Provider<T>.require(condition: (T) -> Boolean, message: (T) -> String): Provider<T> {
    val provider = MapEverythingProvider(this) {
        require(condition(it)) { message(it) }
        it
    }
    addChild(provider)
    return provider
}

/**
 * Creates and returns a new [Provider] that throws an [IllegalArgumentException]
 * with [message] if the value is `null`.
 */
fun <T> Provider<T?>.requireNotNull(message: String = "Required value was null."): Provider<T & Any> {
    return requireNotNull { message }
}

/**
 * Creates and returns a new [Provider] that throws an [IllegalArgumentException]
 * with a message generated by [message] if the value is `null`.
 */
fun <T> Provider<T?>.requireNotNull(message: () -> String): Provider<T & Any> {
    val provider = MapEverythingProvider(this) {
        requireNotNull(it, message)
        it
    }
    addChild(provider)
    return provider
}

private class MapEverythingProvider<T, R>(
    private val provider: Provider<T>,
    private val transform: (T) -> R
) : Provider<R>() {
    override fun loadValue(): R {
        return transform(provider.get())
    }
}

private class MapNonNullProvider<T, R>(
    private val provider: Provider<T>,
    private val transform: (T & Any) -> R
) : Provider<R?>() {
    override fun loadValue(): R? {
        return provider.get()?.let(transform)
    }
}

private class MapEachProvider<T, R, C : MutableCollection<R>>(
    private val provider: Provider<out Collection<T>>,
    private val makeCollection: () -> C,
    private val transform: (T) -> R
) : Provider<C>() {
    override fun loadValue(): C {
        return provider.get().mapTo(makeCollection(), transform)
    }
}

private class MapEachNotNullProvider<T, R : Any, C : MutableCollection<R>>(
    private val provider: Provider<out Collection<T>>,
    private val makeCollection: () -> C,
    private val transform: (T) -> R?
) : Provider<C>() {
    override fun loadValue(): C {
        return provider.get().mapNotNullTo(makeCollection(), transform)
    }
}

private class FlatMapProvider<T, R>(
    private val provider: Provider<List<T>>,
    private val transform: (T) -> List<R>
) : Provider<List<R>>() {
    override fun loadValue(): List<R> {
        return provider.get().flatMap(transform)
    }
}

private class MergeMapsProvider<K, V>(
    private val provider: Provider<List<Map<K, V>>>,
    private val createMap: () -> MutableMap<K, V>
) : Provider<Map<K, V>>() {
    override fun loadValue(): Map<K, V> {
        val newMap = createMap()
        provider.get().forEach { newMap.putAll(it) }
        return newMap
    }
}